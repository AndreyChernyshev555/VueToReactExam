## Практика 1 — состояние (useState ↔ ref)

### Vue

```vue
<template>
  <div>
    <button @click="increment">+</button>
    <span>{{ count }}</span>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const count = ref(0);

function increment() {
  count.value++;
}
</script>
```

### Задание

```
Перепиши компонент на React.
Объясни:
— чем useState концептуально отличается от ref во Vue;
— почему в React нельзя просто изменить переменную напрямую.
```

---

## Практика 2 — эффекты и жизненный цикл

### Vue

```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue';

const width = ref(window.innerWidth);

function onResize() {
  width.value = window.innerWidth;
}

onMounted(() => {
  window.addEventListener('resize', onResize);
});

onUnmounted(() => {
  window.removeEventListener('resize', onResize);
});
</script>

<template>
  <div>Width: {{ width }}</div>
</template>
```

### Задание

```
Реализуй аналогичный функционал на React с использованием useEffect.
Объясни:
— как в React реализуются mounted и unmounted;
— что будет, если забыть функцию очистки.
```

---

## Практика 3 — зависимости эффекта (watch ↔ useEffect)

### Vue

```vue
<script setup>
import { ref, watch } from 'vue';

const query = ref('');
const results = ref([]);

watch(query, async (newValue) => {
  results.value = await fetchData(newValue);
});
</script>
```

### Задание

```
Перепиши пример на React.
Объясни:
— почему useEffect нельзя объявлять async напрямую;
— что должно быть в массиве зависимостей.
```

---

## Практика 4 — вычисляемые значения (useMemo ↔ computed)

### Vue

```vue
<script setup>
import { computed, ref } from 'vue';

const items = ref([1, 2, 3, 4, 5]);

const sum = computed(() =>
  items.value.reduce((a, b) => a + b, 0)
);
</script>
```

### Задание

```
Перепиши пример на React.
Ответь:
— нужен ли здесь useMemo;
— в каких случаях useMemo избыточен.
```

---

## Практика 5 — колбэки и оптимизация

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return <Child onClick={increment} />;
}
```

### Задание

```
Объясни:
— в чем потенциальная проблема этого кода;
— когда стоит использовать функциональную форму setCount;
— когда useCallback действительно нужен.
```

