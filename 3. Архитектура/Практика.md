## Практика 1 — Lifting state up (v-model ↔ React)

### Vue

```vue
<!-- Parent.vue -->
<template>
  <Child v-model="value" />
  <div>Value: {{ value }}</div>
</template>

<script setup>
import { ref } from 'vue';
import Child from './Child.vue';

const value = ref('');
</script>
```

```vue
<!-- Child.vue -->
<template>
  <input v-model="modelValue" />
</template>

<script setup>
defineProps(['modelValue']);
defineEmits(['update:modelValue']);
</script>
```

### Задание

```
Реализуй аналогичное поведение на React.
Ответь:
— где должно храниться состояние;
— как данные передаются вниз и вверх;
— почему в React нет прямого аналога v-model.
```

---

## Практика 2 — Controlled vs Uncontrolled components

```jsx
function Form() {
  return <input />;
}
```

### Задание

```
Реализуй:
1) controlled input;
2) uncontrolled input с использованием ref.

Объясни:
— в чем принципиальная разница между этими подходами;
— в каких случаях каждый из них предпочтительнее.
```

---

## Практика 3 — Props vs State (антипаттерн)

```jsx
function Child({ value }) {
  value = value + '!';
  return <div>{value}</div>;
}
```

### Задание

```
Объясни, почему данный код является антипаттерном.
Как правильно изменить отображаемое значение?
Почему во Vue подобная ошибка менее очевидна?
```

---

## Практика 4 — Context API

```jsx
const ThemeContext = createContext('light');
```

### Задание

```
Реализуй пример с темой приложения:
— Provider в корневом компоненте;
— использование useContext в дочернем компоненте.

Ответь:
— какую проблему решает Context;
— когда Context использовать не стоит.
```

---

## Финальная практическая задача

```
Дано:
— список товаров;
— фильтр по цене;
— компонент списка товаров;
— компонент фильтра.

Требуется:
1) Спроектировать структуру компонентов;
2) Определить, где хранится состояние;
3) Избежать prop drilling;
4) Обосновать архитектурное решение.
```

